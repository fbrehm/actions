---

name: 'Checking the pyproject and flit environment'

################################################################################
# yamllint disable-line rule:truthy
on:
  workflow_call:
    inputs:
      srcdir:
        description: "The source directory for Python modules."
        type: string
        required: false
        default: 'src'
      latest_debian_version:
        description: 'The short name of the latest stable Debian version.'
        type: string
        default: 'bookworm'
    outputs:
      entrypoints:
        description: "A whitespace separated list of entrypoints, which are converted to executable Python scripts."
        value: ${{ jobs.check-pyproject-and-flit.outputs.entrypoints }}
      data_dir:
        description: "The data directory for containing man pages, i18n files a.s.o."
        value: ${{ jobs.check-pyproject-and-flit.outputs.data_dir }}
      locales:
        description: "A whitespace separated list of locales, which are supported by this project, en_US.UTF8 is always included."
        value: ${{ jobs.check-pyproject-and-flit.outputs.locales }}

################################################################################
jobs:

  ###########################
  check-pyproject-and-flit:
    name: "Checking the pyproject and flit environment"
    runs-on: ubuntu-latest
    container: debian:${{ inputs.latest_debian_version }}
    env:
      SRCDIR: ${{ inputs.srcdir }}
    outputs:
      entrypoints: ${{ steps.get-entrypoints.outputs.entrypoints }}
      data_dir: ${{ steps.get-data-dir.outputs.data_dir }}
      locales: ${{ steps.check-locales.outputs.locales }}

    steps:
      - name: "Checking out sources."
        uses: actions/checkout@v5

      - name: 'Check for pyproject.toml'
        shell: bash
        run: |
          echo "Checking for availibility of pyproject.toml"
          if [[ ! -f pyproject.toml ]] ; then
              echo "::error::File pyproject.toml not found."
              exit 5
          fi
          echo "Found pyproject.toml."

      - name: "Check for source directory."
        shell: bash
        run: |
          echo "Checking for availibility of '${{ inputs.srcdir }}' ..."
          if [[ ! -d "${{ inputs.srcdir }}" ]] ; then
              echo "::error::Source directory '${{ inputs.srcdir }}' not found or is not a directory."
              exit 6
          fi
          echo "Found Source directory '${{ inputs.srcdir }}'."

      - name: "Create AWK script for get all keys in a section."
        shell: bash
        id: create-awk-script-keys
        run: |
          echo "Creating AWK script ..."
          lines=$( cat <<-EOF
          	BEGIN {
          	    in_section = 0
          	}

          	{
          	    # Cleaning row: removing leading and trailing whitespaces and cut before comment character
          	    line = \$0
          	    sub(/^[ \t]+/, "", line)
          	    sub(/[ \t]+\$/, "", line)
          	    sub(/[ \t]*[#;].*\$/, "", line)

          	    # Skip on empty row
          	    if (line == "") {
          	        next
          	    }

          	    # Check for section header
          	    if (line ~ /^\[.*\]\$/) {
          	        section = substr(line, 2, length(line) - 2)
          	        if (section == target_section) {
          	            in_section = 1
          	        } else {
          	            in_section = 0
          	        }
          	        next
          	    }

          	    # Perform key-value-pair in target section
          	    if (in_section == 1) {
          	        if (line ~ /^[a-zA-Z0-9_-]+[ \t]*=[ \t]*.*\$/) {
          	            # extract and print key
          	            split(line, a, /[ \t]*=[ \t]*/)
          	            print a[1]
          	        }
          	    }
          	}
          	EOF
          )

          awk_file_keys=$( mktemp get-all-keys-from-section.XXXXXXXXXX.awk )
          echo "Creating AWK script: '${awk_file_keys}'."
          echo "${lines}" > "${awk_file_keys}"

          echo "::group::Content of AWK script:"
          cat "${awk_file_keys}"
          echo "::endgroup::"

          echo "awk_file_keys=${awk_file_keys}" >>$GITHUB_OUTPUT

      - name: "Create AWK script for get the value of a keys in a section."
        shell: bash
        id: create-awk-script-value
        run: |
          echo "Creating AWK script ..."
          lines=$( cat <<-EOF
          	# Script for extracting a value from a INI-file
          	#
          	# Example for calling:
          	# awk -f get_ini_value.awk -v target_section="[build-system]" -v key="build-backend" pyproject.toml

          	BEGIN {
          	  # Defaults
          	  found_section = 0
          	}

          	{
          	  # Strip leading and trailing white spaces
          	  line = \$0
          	  gsub(/^[ \t]+|[ \t]+\$/, "", line)

          	  # Step comments and empty rows
          	  if (line ~ /^;/ || line ~ /^#/) {
          	    next
          	  }
          	  if (length(line) == 0) {
          	    next
          	  }

          	  # Check for the correct section
          	  if (line ~ /^\[.*\]\$/) {
          	    section = substr(line, 2, length(line) - 2)
          	    if (section == target_section) {
          	      found_section = 1
          	    } else {
          	      found_section = 0
          	    }
          	    next
          	  }

          	  # If we are in the correct section
          	  if (found_section == 1) {
          	    if (line ~ "^" key "[ \t]*=.*") {
          	      split(line, arr, /[ \t]*=[ \t]*/)

          	      value = arr[2]

          	      gsub(/^"|"\$/, "", value)
          	      gsub(/^'|'\$/, "", value)

          	      print value

          	      exit
          	    }
          	  }
          	}
          	EOF
          )

          awk_file_value=$( mktemp get-value-from-section.XXXXXXXXXX.awk )
          echo "Creating AWK script: '${awk_file_value}'."
          echo "${lines}" > "${awk_file_value}"

          echo "::group::Content of AWK script:"
          cat "${awk_file_value}"
          echo "::endgroup::"

          echo "awk_file_value=${awk_file_value}" >>$GITHUB_OUTPUT

      - name: "Get entrypoints from pyproject.toml."
        id: get-entrypoints
        shell: bash
        run: |
          awk_file_keys="${{ steps.create-awk-script-keys.outputs.awk_file_keys }}"

          echo -e "Get all entry points ..."
          ENTRYPOINTS=''
          cmd="awk -f '${awk_file_keys}' -v target_section=project.scripts pyproject.toml"
          echo "Calling ${cmd}"
          result=$( eval ${cmd} )
          echo "Got raw entrypoints from AWK script: '${result}'"

          if [[ -n "${result}" ]] ; then
              echo "Evaluate entrypoints ..."
              for entrypoint in ${result}; do
                  if [[ -n "${ENTRYPOINTS}" ]] ; then
                      ENTRYPOINTS+=" "
                  fi
                  ENTRYPOINTS+="${entrypoint}"
              done
          fi

          echo "entrypoints=${ENTRYPOINTS}" >>"$GITHUB_OUTPUT"

          if [[ -n "${ENTRYPOINTS}" ]] ; then
              echo "::notice title=Check environment::Found entrypoints: ${ENTRYPOINTS}"
          else
              echo "::notice title=Check environment::Did not found any entrypoints."
          fi

      - name: "Check for flit as build system"
        id: check-for-flit
        shell: bash
        run: |
          awk_file_value="${{ steps.create-awk-script-value.outputs.awk_file_value }}"
          target_build_backend='flit_core.buildapi'

          echo "Get name of the build system."

          cmd="awk -f '${awk_file_value}' -v target_section=build-system -v key=build-backend pyproject.toml"
          echo "Calling ${cmd}"
          build_system=$( eval ${cmd} )
          echo "Got build system from AWK script: '${build_system}'"

          if [[ "${build_system}" != "${target_build_backend}" ]] ; then
              echo "::error::Found invalid build-backend '${build_system}', and not '${target_build_backend}' in pyproject.toml."
              exit 7
          fi

          echo "::notice title=Check environment::Found build backend '${build_system}' in pyproject.toml."

      - name: "Get directory for external data."
        id: get-data-dir
        shell: bash
        run: |
          awk_file_value="${{ steps.create-awk-script-value.outputs.awk_file_value }}"

          echo "Get the directory for external data."

          DATA_DIR=''

          cmd="awk -f '${awk_file_value}' -v target_section=tool.flit.external-data -v key=directory pyproject.toml"
          echo "Calling ${cmd}"
          DATA_DIR=$( eval ${cmd} )

          echo "data_dir=${DATA_DIR}" >>"$GITHUB_OUTPUT"

          if [[ -n "${DATA_DIR}" ]] ; then
              echo "::notice title=Check environment::Found data directory: ${DATA_DIR}"
          else
              echo "::notice title=Check environment::Did not found data directory."
          fi

      - name: "Evaluating all supported locales by the current project."
        id: check-locales
        shell: bash
        run: |
          cur_locales="en_US.UTF-8\n"

          declare -A main_locale=()
          main_locale['af']='af_ZA'
          main_locale['ar']='ar_SA'
          main_locale['az']='az_AZ'
          main_locale['be']='be_BY'
          main_locale['bg']='bg_BG'
          main_locale['bn']='bn_IN'
          main_locale['bs']='bs_BA'
          main_locale['ca']='ca_ES'
          main_locale['cs']='cs_CZ'
          main_locale['cy']='cy_GB'
          main_locale['da']='da_DK'
          main_locale['de']='de_DE'
          main_locale['el']='el_GR'
          main_locale['en']='en_US'
          main_locale['es']='es_ES'
          main_locale['et']='et_ET'
          main_locale['eu']='eu_ES'
          main_locale['fa']='fa_IR'
          main_locale['fi']='fi_FI'
          main_locale['fo']='fo_FO'
          main_locale['fr']='fr_FR'
          main_locale['gl']='gl_ES'
          main_locale['gu']='gu_IN'
          main_locale['he']='he_IL'
          main_locale['hi']='hi_IN'
          main_locale['hr']='hr_HR'
          main_locale['hu']='hu_HU'
          main_locale['hy']='hy_HY'
          main_locale['id']='id_ID'
          main_locale['is']='is_IS'
          main_locale['it']='it_IT'
          main_locale['ja']='ja_JP'
          main_locale['ka']='ka_GE'
          main_locale['kk']='kk_KZ'
          main_locale['kn']='kn_IN'
          main_locale['ko']='ko_KR'
          main_locale['kok']='kok_IN'
          main_locale['lt']='lt_LT'
          main_locale['lv']='lv_LV'
          main_locale['mk']='mk_MK'
          main_locale['ml']='ml_IN'
          main_locale['mn']='mn_MN'
          main_locale['ms']='ms_MY'
          main_locale['nb']='nb_NO'
          main_locale['nl']='nl_NL'
          main_locale['nn']='nn_NO'
          main_locale['pa']='pa_IN'
          main_locale['pl']='pl_PL'
          main_locale['pt']='pt_PT'
          main_locale['ro']='ro_RO'
          main_locale['ru']='ru_RU'
          main_locale['se']='se_NO'
          main_locale['sk']='sk_SK'
          main_locale['sl']='sl_SI'
          main_locale['sq']='sq_AL'
          main_locale['sr']='sr_SR'
          main_locale['sv']='sv_SE'
          main_locale['sw']='sw_KE'
          main_locale['syr']='syr_SY'
          main_locale['ta']='ta_IN'
          main_locale['te']='te_IN'
          main_locale['th']='th_TH'
          main_locale['tn']='tn_ZA'
          main_locale['tr']='tr_TR'
          main_locale['uk']='uk_UA'
          main_locale['uz']='uz_UZ'
          main_locale['vi']='vi_VN'
          main_locale['xh']='xh_ZA'
          main_locale['zh']='zh_CN'
          main_locale['zu']='zu_ZA'

          if [[ -d locale ]] ; then
              echo "There seems to be supported locales."
              for ldir in locale/* ; do
                  if [[ ! -d "${ldir}" ]] ; then
                      continue
                  fi
                  cur_locale=$( basename "${ldir}" )
                  if [[ "${cur_locale}" =~ ^[a-z][a-z][a-z]?(_[A-Z][A-Z])?(\.[a-z1-9][a-z0-9:_\.-]*)?$ ]] ; then
                      bare_locale=$( echo "${cur_locale}" | sed -e 's/\..*//' )
                      charset=''
                      if echo "${cur_locale}" | grep -q -P '\.' ; then
                          charset=$( echo "${cur_locale}" | sed -e 's/.*\.//' | tr '[:lower:]' '[:upper:]')
                      fi
                      if [[ -z "${charset}" ]] ; then
                          charset='UTF-8'
                      fi
                      if iconv -l | grep -q "^${charset}//" ; then
                          :
                      else
                          echo "Found invalid character set '${charset}' in locale '${cur_locale}'."
                          continue
                      fi

                      language=$( echo "${bare_locale}" | sed -e 's/_.*//' | tr '[:upper:]' '[:lower:]' )
                      if [[ "${main_locale[${language}]+abc}" ]] ; then
                          :
                      else
                          echo "Language '${language}' in locale '${cur_locale}' is not supported."
                          continue
                      fi
                      country=''
                      if echo "${bare_locale}" | grep -q -P '_' ; then
                          country=$( echo "${bare_locale}" | sed -e 's/.*_//' | tr '[:lower:]' '[:upper:]' )
                      fi
                      if [[ -z "${country}" ]] ; then
                          l_locale="${main_locale[${language}]}"
                      else
                          l_locale="${language}_${country}"
                      fi

                      used_locale="${l_locale}.${charset}"
                      echo "Found supported locale '${used_locale}'."

                      if [[ "${used_locale}" == 'en_US.UTF-8' ]] ; then
                          continue
                      fi

                      cur_locales+="${used_locale}\n"

                  else
                      echo "Found invalid locale '${cur_locale}'."
                  fi
              done
          else
              echo "This project does not support locales (other than en_US.UTF-8)."
          fi

          found_locales=''
          for locale in $( echo -e "${cur_locales}" | grep -v -P '^\s*$' | sort -i | sed -e 's/^[ 	]*//' -e 's/[ 	]$//' ) ; do
              if [[ -z "${locale}" ]] ; then
                  continue
              fi
              if [[ -n "${found_locales}" ]] ; then
                  found_locales+=" "
              fi
              found_locales+="${locale}"
          done

          echo "All found locales: '${found_locales}'"
          echo "locales=${found_locales}" >>"$GITHUB_OUTPUT"

# vim: et tabstop=2 expandtab shiftwidth=2 softtabstop=2 list
